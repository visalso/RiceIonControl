# *****************************************************************
# IonControl:  Copyright 2016 Sandia Corporation
# This Software is released under the GPL license detailed
# in the file "license.txt" in the top-level IonControl directory
# *****************************************************************

import collections
from PyQt5 import QtCore
import os
import logging
import traceback
import numpy
from datetime import datetime
from .Script import ScriptException
from modules.quantity import is_Q, Q
from trace.PlottedTrace import PlottedTrace
from trace.TraceCollection import TraceCollection
from trace import pens
from pyqtgraph.graphicsItems.ViewBox import ViewBox
import functools
import pytz
from persist.MeasurementLog import  Measurement, Parameter, Result
from copy import deepcopy

class ScriptHandler(QtCore.QObject):
    """The ScriptHandler is what handles all the interfacing between the Script and the GUI. The Script
    emits signals, which are picked up by the ScriptHandler, which executes the necessary changes on the
    GUI."""
    def __init__(self, script, experimentUi):
        super().__init__()
        self.experimentUi = experimentUi
        self.camera = experimentUi.CameraWindow
        self.scanExperiment = experimentUi.tabDict['Scan']
        self.globalVariablesUi = experimentUi.globalVariablesUi
        self.voltageControlWindow = experimentUi.voltageControlWindow
        self.scanControlWidget = self.scanExperiment.scanControlWidget
        self.evaluationControlWidget = self.scanExperiment.evaluationControlWidget
        self.analysisControlWidget = self.scanExperiment.analysisControlWidget
        self.fitWidget = self.scanExperiment.fitWidget
        self.pulser = self.experimentUi.pulser
        self.AWGUiDict = experimentUi.AWGUiDict
        self.currentLines = []
        self.script = script
        self.scriptTraces = dict() #Place to put traces generated by the script
        self.traceAlreadyCreated = dict() #Place to keep track of whether or not a given trace has been added to the traceUi
        self.globalVariablesRevertDict = dict() #original values of global variables which are changed
        self.namedTraceList = set()
        
        #Experiment information signals
        self.scanExperiment.progressUi.stateChanged.connect(self.onScanStateChanged)
        self.analysisControlWidget.analysisResultSignal.connect(self.onAnalysisResult)
        self.scanExperiment.evaluatedDataSignal.connect(self.onData)
        self.scanExperiment.allDataSignal.connect(self.onAllData)
        
        #status signals
        self.script.locationSignal.connect( self.onLocation )
        self.script.exceptionSignal.connect( self.onException )
        self.script.consoleSignal.connect( self.onConsoleSignal )

        #action signals
        self.script.setGlobalSignal.connect(self.onSetGlobal)
        self.script.addGlobalSignal.connect(self.onAddGlobal)
        self.script.pauseScriptSignal.connect(self.onPauseScriptFromScript)
        self.script.stopScriptSignal.connect(self.onStopScriptFromScript)
        self.script.startScanSignal.connect(self.onStartScan)
        self.script.setScanSignal.connect(self.onSetScan)
        self.script.setEvaluationSignal.connect(self.onSetEvaluation)
        self.script.setAnalysisSignal.connect(self.onSetAnalysis)
        self.script.setAnalysisInitialSignal.connect(self.onSetAnalysisInitial)
        self.script.saveCameraSignal.connect(self.onSaveCamera)
        self.script.startAcquireCameraSignal.connect(self.onStartAcquireCamera)
        self.script.stopAcquireCameraSignal.connect(self.onStopAcquireCamera)
        self.script.detectIonsCameraSignal.connect(self.onDetectIons)
        self.script.detectIonsWriteToFileSignal.connect(self.onDetectIonsWriteToFile)
        self.script.setFileNameCameraSignal.connect(self.onSetFileNameCamera)
        self.script.plotPointSignal.connect(self.onPlotPoint)
        self.script.plotListSignal.connect(self.onPlotList)
        self.script.addPlotSignal.connect(self.onAddPlot)
        self.script.pauseScanSignal.connect(self.onPauseScan)
        self.script.stopScanSignal.connect(self.onStopScan)
        self.script.abortScanSignal.connect(self.onAbortScan)
        self.script.createTraceSignal.connect(self.onCreateTrace)
        self.script.closeTraceSignal.connect(self.onCloseTrace)
        self.script.checkTraceSignal.connect(self.onCheckTrace)
        self.script.uncheckTraceSignal.connect(self.onUncheckTrace)
        self.script.genericCallSignal.connect(self.onGenericCall)
        self.script.consolePrintSignal.connect( self.onConsolePrintSignal )
        self.script.fitSignal.connect(self.onFit)
        self.script.namedTraceSignal.connect(self.onPushToNamedTrace)
        self.script.loadVoltageDefSignal.connect(self.onLoadVoltageDef)
        self.script.programAWGSignal.connect(self.onProgramAWG)
        self.script.setAWGSignal.connect(self.onSetAWG)
        self.script.checkPulseVariableSignal.connect(self.onCheckPulseVariable)
        self.script.commentOutPulseLinesSignal.connect(self.onCommentOutPulseLines)
        self.script.unCommentOutPulseLinesSignal.connect(self.onUnCommentOutPulseLines)
        self.script.checkAcquireWithCameraSignal.connect(self.onCheckAcquireWithCamera)
        self.script.initializeAWGSignal.connect(self.onInitializeAWG)
        self.script.setAWGVariableSignal.connect(self.onSetAWGVariable)
        self.script.checkAWGRowSignal.connect(self.onCheckAWGRow)
        self.script.uncheckAWGRowSignal.connect(self.onUncheckAWGRow)

        #finished signal
        self.script.finished.connect(self.onFinished)

    def scriptCommand(func):#@NoSelf
        """Decorator for script commands. 
        
        Catches exceptions, sets the script exception variables, and wakes the script after the
        specified action has been completed.
        """
        def baseScriptCommand(self, *args, **kwds):
            logger = logging.getLogger(__name__)
            try:
                error, message = func(self, *args, **kwds)
                if error and message:
                    logger.error(message)
                    self.writeToConsole(message, error=True)
                    raise ScriptException(message)
                elif error and (not message):
                    raise ScriptException('')
                elif (not error) and message:
                    logger.debug(message)
                    self.writeToConsole(message)
            except Exception as e:
                with QtCore.QMutexLocker(self.script.mutex):
                    self.script.exception = e
                    logger.error(traceback.print_exc())
            finally:
                self.script.guiWait.wakeAll()
        baseScriptCommand.__name__ = func.__name__
        baseScriptCommand.__doc__ = func.__doc__
        return baseScriptCommand

    @QtCore.pyqtSlot()
    @scriptCommand
    def onCalibrateROIs(self):
        pass

    @QtCore.pyqtSlot(str, float, str)
    @scriptCommand
    def onAddGlobal(self, name, value, unit):
        """Add a global 'name' and set it to 'value, unit'"""
        name = str(name) #signal is passed as a QString
        value = float(value)
        unit = str(unit)
        magValue = Q(value, unit)
        doesNotExist = name not in list(self.globalVariablesUi.keys())
        if doesNotExist:
            self.globalVariablesUi.model.addVariable(name)
            message = "Global variable {0} created\n".format(name)
        else:
            message = "Global variable {0} already exists\n".format(name)
        self.globalVariablesUi.model.update([('Global', name, magValue)])
        message +=  "Global variable {0} set to {1} {2}".format(name, value, unit)
        error = False
        return (error, message)

    @QtCore.pyqtSlot(bool)
    @scriptCommand
    def onCheckAcquireWithCamera(self, toggle):

        self.experimentUi.checkBoxUseCamera.setChecked(toggle)
        message = "Acquire with Camera box checked"
        error = False

        return (error, message)

    @QtCore.pyqtSlot (str, int)
    @scriptCommand
    def onCheckPulseVariable(self, name, toggle):
        if self.experimentUi.scanExperiment.pulseProgramUi.variableTableModel.setVarEnabledScript(name, toggle) is \
                False:
            message = "Pulse Variable not found"
            error = True
        else:
            message = "Pulse Variable checked"
            error = False
        return (error, message)

    @QtCore.pyqtSlot(int, int)
    @scriptCommand
    def onCommentOutPulseLines(self, startingLine, endingLine):
        if startingLine > endingLine or startingLine < 0 or endingLine < 0:
            message = "Invalid line number parameters."
            error = True
        else:
            filepath = os.path.join('Z:/Lab/Sandia Box Projects/10_DDS_new/config/PulseProgramsPlus', 'CryoLab (2).ppp')
            if not os.path.exists('Z:/Lab/Sandia Box Projects/10_DDS_new/config/PulseProgramsPlus'):
                message = "File path does not exist"
                error = True
            else:
                file = open(filepath, "r")
                data = file.readlines()
                for x in range(startingLine-1, endingLine):
                    data[x] = '#' + data[x]

                file = open(filepath, "w")
                file.writelines(data)

                error = False
                message = "Successfully commented out"
        return (error, message)

    @QtCore.pyqtSlot(int, int)
    @scriptCommand
    def onUnCommentOutPulseLines(self, startingLine, endingLine):
        if startingLine > endingLine or startingLine < 0 or endingLine < 0:
            message = "Invalid line number parameters."
            error = True
        else:
            filepath = os.path.join('Z:/Lab/Sandia Box Projects/10_DDS_new/config/PulseProgramsPlus', 'CryoLab (2).ppp')
            if not os.path.exists('Z:/Lab/Sandia Box Projects/10_DDS_new/config/PulseProgramsPlus'):
                message = "File path does not exist"
                error = True
            else:
                file = open(filepath, "r")
                data = file.readlines()
                for x in range(startingLine - 1, endingLine):
                    data[x] = data[x].replace("#", "", 1)

                file = open(filepath, "w")
                file.writelines(data)

                error = False
                message = "Successfully commented out"
        return (error, message)

    @QtCore.pyqtSlot(str, float, str)
    @scriptCommand
    def onSetGlobal(self, name, value, unit):
        """Set global 'name' to 'value, unit'"""
        name = str(name) #signal is passed as a QString
        value = float(value)
        unit = str(unit)
        magValue = Q(value, unit)
        doesNotExist = name not in list(self.globalVariablesUi.keys())
        if doesNotExist:
            message = "Global variable {0} does not exist.".format(name)
            error = True
        else:
            if name not in self.globalVariablesRevertDict: #entry is added to revert dict only the first time a global is set in a script
                self.globalVariablesRevertDict[name] = deepcopy(self.globalVariablesUi.globalDict[name])
            self.globalVariablesUi.model.update([('Global', name, magValue)])
            message = "Global variable {0} set to {1} {2}".format(name, value, unit)
            error = False
        return (error, message)

    @QtCore.pyqtSlot(str, str)
    @scriptCommand
    def onLoadVoltageDef(self, name, path):
        """Load voltage definition given by name and the associated '_shuttling.xml' from path"""
        if self.voltageControlWindow: # can be None
            if path:
                name = os.path.join(path,name)
            self.voltageControlWindow.voltageFilesUi.loadVoltageDef(name)
            message = "Loaded voltage definition file {0} ".format(name)
            error = False
        else:
            message = "Voltage control was disabled by the UI"
            error = True
        return (error, message)

    @QtCore.pyqtSlot(str, object, object)
    @scriptCommand
    def onGenericCall(self, funcname, args, kwargs):
        """Return a generic piece of data from the program, specified by 'funcname'
        """
        funcname = str(funcname)
        try:
            with QtCore.QMutexLocker(self.script.mutex):
                self.script.genericResult = getattr(self, funcname)(*args, **kwargs)
            self.script.genericWait.wakeAll()
        except Exception as e:
            return True, str(e)
        return False, "{0}{1} executed".format(funcname, args)

    def getGlobal(self, name):
        """Return the value of a global variable, returns a quantity 'q' with 
        magnitude given by q.m and units given by q.u"""
        if name in self.globalVariablesUi.globalDict.keys():
            return self.globalVariablesUi.globalDict[name]
        return ScriptException("Global '{}' does not exist!".format(name))

    @QtCore.pyqtSlot(list)
    @scriptCommand
    def onStartScan(self, globalOverrides=list()):
        """Start the scan
        globalOverrrides is list of (name, magnitude) values or list of (name, (value, unit)) values
        that will override global variables during the scan
        """
        logger = logging.getLogger(__name__)
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.scanIsRunning = True
            self.script.analysisReady = False
            self.script.dataReady = False
            self.script.allDataReady = False
        # make sure we hand on a list of (key, magnitude) pairs
        myGlobalOverrides = list()
        for key, value in globalOverrides:
            if not is_Q(value):
                if isinstance(value, collections.Sized):
                    value = Q(value[0], value[1])
                else:
                    value = Q(value)
            myGlobalOverrides.append((key, value))
        self.experimentUi.onStart(globalOverrides=myGlobalOverrides)
        scan = self.scanControlWidget.settingsName
        evaluation = self.evaluationControlWidget.settingsName
        analysis = self.analysisControlWidget.currentAnalysisName
        message = "Scan started at {0} with scan = {1}, evaluation = {2}, analysis = {3}".format(str(datetime.now()), scan, evaluation, analysis)
        logger.info(message)
        self.writeToConsole(message, color='green')
        return (False, None)

    @QtCore.pyqtSlot()
    @scriptCommand
    def onPauseScan(self):
        self.experimentUi.actionPause.trigger()
        error = False
        message = "Scan paused"
        return (error, message)

    @QtCore.pyqtSlot()
    @scriptCommand
    def onSaveCamera(self):
        if self.camera is None:
            message = "Camera not connected"
            error = True
        else:
            self.camera.onSave()
            error = False
            message = "Camera data saved"
        return (error, message)

    @QtCore.pyqtSlot()
    @scriptCommand
    def onStartAcquireCamera(self):
        if self.camera is None:
            message = "Camera not connected"
            error = True
        else:
            self.camera.actionAcquire.setChecked(True)
            self.camera.onAcquire()
            error = False
            message = "Camera data acquired"
        return (error, message)

    @QtCore.pyqtSlot()
    @scriptCommand
    def onStopAcquireCamera(self):
        if self.camera is None:
            message = "Camera not connected"
            error = True
        else:
            self.camera.actionAcquire.setChecked(False)
            self.camera.onAcquire()
            error = False
            message = "Camera data acquired"
        return (error, message)

    @QtCore.pyqtSlot()
    @scriptCommand
    def onDetectIons(self):
        if self.camera is None:
            message = "Camera not connected"
            error = True
        else:
            self.camera.onDetecter()
            error = False
            message = "Camera ions detected"
        return (error, message)

    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onDetectIonsWriteToFile(self, name):
        if self.camera is None:
            message = "Camera not connected"
            error = True
        else:
            self.camera.onDetecterWriteToFile(name)
            error = False
            message = "Camera ions detected and written to file IonPositions.txt."
        return (error, message)

    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onSetFileNameCamera(self, name):
        if self.camera is None:
            message = "Camera not connected"
            error = True
        else:
            self.camera.onEditFileNameScript(name)
            error = False
            message = "Camera file name set"
        return (error, message)
        
    @QtCore.pyqtSlot()
    @scriptCommand
    def onStopScan(self):
        self.experimentUi.actionStop.trigger()
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.scanIsRunning = False
        error = False
        message = "Scan stopped"
        return (error, message)
        
    @QtCore.pyqtSlot()
    @scriptCommand
    def onAbortScan(self):
        self.experimentUi.actionAbort.trigger()
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.scanIsRunning = False
        error = False
        message = "Scan aborted"
        return (error, message)

    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onSetScan(self, name):
        name = str(name)
        doesNotExist = (self.scanControlWidget.comboBox.findText(name)==-1)
        if doesNotExist:
            message = "Scan {0} does not exist.".format(name)
            error = True
        else:
            self.scanControlWidget.loadSetting(name)
            message = "Scan set to {0}".format(name)
            error = False
        return (error, message)
    
    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onSetEvaluation(self, name):
        name = str(name)
        doesNotExist = (self.evaluationControlWidget.comboBox.findText(name)==-1)
        if doesNotExist:
            message = "Evaluation {0} does not exist.".format(name)
            error = True
        else:
            self.evaluationControlWidget.loadSetting(name)
            message = "Evaluation set to {0}".format(name)
            error = False
        return (error, message)
    
    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onSetAnalysis(self, name):
        name = str(name)
        doesNotExist = (name not in self.analysisControlWidget.analysisDefinitionDict)
        if doesNotExist:
            message = "Analysis {0} does not exist.".format(name)
            error = True
        else:
            self.analysisControlWidget.onLoadAnalysisConfiguration(name)
            message = "Analysis set to {0}".format(name)
            error = False
        return (error, message)

    @QtCore.pyqtSlot(int, float)
    @scriptCommand
    def onSetAnalysisInitial(self, row, value):
        error = False
        message = "Initial Value set."
        self.analysisControlWidget.fitfunctionTableModel.setStartParameters(row, value)
        return (error, message)

    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onInitializeAWG(self, AWGname):
        AWGname = str(AWGname)
        if AWGname not in self.AWGUiDict:
            message = "AWG {0} does not exist".format(AWGname)
            error = True
        else:
            self.AWGUiDict[AWGname].device.initialize()
            message = "AWG {0} initialized".format(AWGname)
            error = False
        return (error, message)

    @QtCore.pyqtSlot(str, str, str)
    @scriptCommand
    def onSetAWGVariable(self, AWGname, name, value):
        AWGname = str(AWGname)
        if AWGname not in self.AWGUiDict:
            message = "AWG {0} does not exist".format(AWGname)
            error = True
        elif self.AWGUiDict[AWGname].tableModel.setValueScript(name, value) is False:
            message = "AWG row does not exist"
            error = True
        else:
            message = "AWG row value set"
            error = False
        return (error, message)


    @QtCore.pyqtSlot(str, str)
    @scriptCommand
    def onSetAWG(self, AWGname, name):
        AWGname = str(AWGname)
        name = str(name)
        if AWGname not in self.AWGUiDict:
            message = "AWG {0} does not exist".format(AWGname)
            error = True
        else:
            doesNotExist = (self.AWGUiDict[AWGname].settingsComboBox.findText(name)==-1)
            if doesNotExist:
                message = "AWG {0} settings {1} does not exist.".format(AWGname, name)
                error = True
            else:
                self.AWGUiDict[AWGname].loadSetting(name)
                message = "AWG {0} settings set to {1}".format(AWGname, name)
                error = False
        return (error, message)

    @QtCore.pyqtSlot(str, str)
    @scriptCommand
    def onCheckAWGRow(self, AWGname, rowName):
        AWGname = str(AWGname)
        if AWGname not in self.AWGUiDict:
            message = "AWG {0} does not exist".format(AWGname)
            error = True
        else:
            for awgChannelUi in self.AWGUiDict[AWGname].awgChannelUiList:
                index = awgChannelUi.segmentView.getIndex(rowName)

                if index is None:
                    message = "AWG row {0} does not exist".format(rowName)
                    error = True
                    break
                else:
                    awgChannelUi.segmentModel.setEnabled(index[0], QtCore.Qt.Checked)
                    message = "AWG {0} checked row {1}".format(AWGname, rowName)
                    error = False
                    break
        return (error, message)

    @QtCore.pyqtSlot(str, str)
    @scriptCommand
    def onUncheckAWGRow(self, AWGname, rowName):
        AWGname = str(AWGname)
        if AWGname not in self.AWGUiDict:
            message = "AWG {0} does not exist".format(AWGname)
            error = True
        else:
            for awgChannelUi in self.AWGUiDict[AWGname].awgChannelUiList:
                index = awgChannelUi.segmentView.getIndex(rowName)

                if index is None:
                    message = "AWG row {0} does not exist".format(rowName)
                    error = True
                    break
                else:
                    awgChannelUi.segmentModel.setEnabled(index[0], QtCore.Qt.Unchecked)
                    message = "AWG {0} unchecked row {1}".format(AWGname, rowName)
                    error = False
                    break
        return (error, message)

    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onProgramAWG(self, AWGname):
        AWGname = str(AWGname)
        if AWGname not in self.AWGUiDict:
            message = "AWG {0} does not exist".format(AWGname)
            error = True
        else:
            self.AWGUiDict[AWGname].device.program()
            message = "AWG {0} programmed".format(AWGname)
            error = False
        return (error, message)

    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onAddPlot(self, name):
        if name not in list(self.scanExperiment.plotDict.keys()):
            self.scanExperiment.addPlot(str(name))
            message = 'Plot {0} added'.format(name)
        else:
            message = 'Plot {0} already exists'.format(name)
        error = False
        return (error, message)
    
    @QtCore.pyqtSlot(list)
    @scriptCommand
    def onCreateTrace(self, traceCreationData):
        traceCreationData = list(map(str, traceCreationData))
        [traceName, plotName, xUnit, xLabel, comment] = traceCreationData
        if plotName not in self.scanExperiment.plotDict:
            message = "plot {0} does not exist".format(plotName)
            error = True
        else:
            traceCollection = TraceCollection()
            yColumnName = 'y0'
            plottedTrace = PlottedTrace(traceCollection, self.scanExperiment.plotDict[plotName], pens.penList, xColumn = 'x',
                                        yColumn=yColumnName, name=traceName, xAxisUnit = xUnit, xAxisLabel = xLabel, windowName=plotName)
            self.scanExperiment.plotDict[plotName]["view"].enableAutoRange(axis=ViewBox.XAxis)
            plottedTrace.traceCollection.name = self.script.shortname
            commentIntro = "Created by script {0}".format(self.script.shortname)
            plottedTrace.traceCollection.comment = commentIntro + " -- " + comment if comment else commentIntro
            plottedTrace.traceCollection.autoSave = True
            plottedTrace.traceCollection.filenamePattern = traceName
            self.scriptTraces[traceName] = plottedTrace
            self.traceAlreadyCreated[traceName] = False #Keep track of whether the trace has already been added
            error = False
            message = "Added trace {0}\n plot: {1}\n xUnit: {2}\n xLabel: {3}\n comment: {4}".format(traceName, plotName, xUnit, xLabel, comment)
        return (error, message)

    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onCloseTrace(self, traceName):
        traceName = str(traceName)
        if traceName not in self.scriptTraces:
            message = "Trace {0} does not exist".format(traceName)
            error = True
        else:
            plottedTrace = self.scriptTraces.pop(traceName) #remove from the list of script traces
            plottedTrace.traceCollection.description["traceFinalized"] = datetime.now(pytz.utc)
            plottedTrace.traceCollection.save()
            self.registerMeasurement(plottedTrace)
            message = "Trace {0} closed".format(traceName)
            error = False
        return error, message

    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onCheckTrace(self, traceName):
        traceName = str(traceName)
        trigger = True
        self.scanExperiment.traceui.traceView.selectAll()
        for node in self.scanExperiment.traceui.traceView.selectedNodes():
            try:
                if (node.content.name == traceName):
                    trigger = False
                    index = self.scanExperiment.traceui.model.indexFromNode(node)
                    self.scanExperiment.traceui.model.checkboxChangeScript(index, QtCore.Qt.Checked)
            except AttributeError as error:
                pass
        self.scanExperiment.traceui.traceView.clearSelection()
        if (trigger):
            message = "Trace {0} not found".format(traceName)
            error = True
        else:
            message = "Trace {0} checked".format(traceName)
            error = False
        return error, message

    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onUncheckTrace(self, traceName):
        traceName = str(traceName)
        trigger = True
        self.scanExperiment.traceui.traceView.selectAll()
        for node in self.scanExperiment.traceui.traceView.selectedNodes():
            try:
                if (node.content.name == traceName):
                    trigger = False
                    index = self.scanExperiment.traceui.model.indexFromNode(node)
                    self.scanExperiment.traceui.model.checkboxChangeScript(index, QtCore.Qt.Unchecked)
            except AttributeError as error:
                pass
        self.scanExperiment.traceui.traceView.clearSelection()
        if (trigger):
            message = "Trace {0} not found".format(traceName)
            error = True
        else:
            message = "Trace {0} unchecked".format(traceName)
            error = False
        return error, message

    @QtCore.pyqtSlot(str, str)
    @scriptCommand
    def onFit(self, fitName, traceName):
        fitName = str(fitName)
        traceName = str(traceName)
        fitAnalysisIndex = self.fitWidget.fitSelectionComboBox.findText(fitName)
        if fitAnalysisIndex < 0:
            message = "Fit '{0}' does not exist.".format(fitName)
            error = True
        elif traceName not in self.scriptTraces:
            message = "Trace '{0}' does not exist".format(traceName)
            error = True
        else:
            plottedTrace = self.scriptTraces[traceName]
            self.fitWidget.fitSelectionComboBox.setCurrentIndex(fitAnalysisIndex)
            message = "Fitting trace '{0}' using fit '{1}'".format(traceName, fitName)
            self.fitWidget.fit(plottedTrace)
            with QtCore.QMutexLocker(self.script.mutex):
                self.script.fitResults.clear()
                self.script.fitResults['error'] = dict()
                for index, parameter in enumerate(plottedTrace.fitFunction.parameterNames):
                    self.script.fitResults[parameter] = plottedTrace.fitFunction.parameters[index]
                    self.script.fitResults['error'][parameter] = plottedTrace.fitFunction.parametersConfidence[index]
            error = False
        return (error, message)

    @QtCore.pyqtSlot(float, float, str, int)
    @scriptCommand
    def onPlotPoint(self, x, y, traceName, plotStyle=-1):
        """Plot point (x,y) to traceName"""
        traceName = str(traceName)
        error, message = self.plotList([x], [y], traceName, plotStyle=plotStyle)
        return (error, message) 
        
    @QtCore.pyqtSlot(list, list, str, bool, int)
    @scriptCommand
    def onPlotList(self, xList, yList, traceName, overwrite=False, plotStyle=-1):
        """Plot [x1, x2,...], [y1, y2,...] to traceName"""
        traceName = str(traceName)
        error, message = self.plotList(xList, yList, traceName, overwrite, plotStyle=plotStyle)
        return (error, message)
        
    def plotList(self, xList, yList, traceName, overwrite=False, plotStyle=-1):
        """Plot [x1, x2,...], [y1, y2,...] to traceName"""
        try:
            plottedTrace = self.scriptTraces[traceName]
            created = self.traceAlreadyCreated[traceName]
        except KeyError:
            message = "Trace {0} does not exist".format(traceName)
            error = True
            return (error, message)
        if not (len(xList)==len(yList)):
            message = 'x and y lists are of unequal lengths'
            error = True
            return (error, message)
        else:
            if created:
                if not overwrite:
                    plottedTrace.x = numpy.append(plottedTrace.x, xList)
                    plottedTrace.y = numpy.append(plottedTrace.y, yList)
                else:
                    plottedTrace.x = xList
                    plottedTrace.y = yList
                plottedTrace.replot()
            else:
                plottedTrace.x = numpy.array(xList)
                plottedTrace.y = numpy.array(yList)
                self.scanExperiment.traceui.addTrace(plottedTrace, pen=-1, style=plotStyle)
                if self.scanExperiment.traceui.expandNew:
                    self.scanExperiment.traceui.expand(plottedTrace)
                self.scanExperiment.traceui.resizeColumnsToContents()
                self.traceAlreadyCreated[traceName] = True
            message = '{0}, {1} plotted to trace: {2}'.format(xList, yList, traceName)
            error = False
        return (error, message)


    @QtCore.pyqtSlot(str, str, int, float, str, bool)
    @scriptCommand
    def onPushToNamedTrace(self, topNode, child, row, data, col, ignorenans):
        self.namedTraceList.add(topNode)
        self.scanExperiment.namedTraceui.updateExternally(topNode, child, row, data, col, ignoreTrailingNaNs=ignorenans)
        message = 'pushed value {0} to named trace {1}'.format(data, topNode+'_'+child)
        error = False
        return (error, message)

    @QtCore.pyqtSlot()
    @scriptCommand
    def onPauseScriptFromScript(self):
        self.experimentUi.scriptingWindow.onPauseScript(True)
        message = None
        error = False
        return (error, message)

    @QtCore.pyqtSlot()
    @scriptCommand
    def onStopScriptFromScript(self):
        self.onStopScript()
        message = 'script stopped'
        error = False
        return (error, message)

    @QtCore.pyqtSlot(str, bool, str)
    def onConsolePrintSignal(self, message, error, color):
        self.writeToConsole(message, error=error, color=color)
    
    def onStartScript(self):
        """Runs when start script button clicked. Starts the script and disables some aspects of the script GUI"""
        if not self.script.isRunning():
            self.globalVariablesRevertDict.clear()
            with QtCore.QMutexLocker(self.script.mutex):
                self.script.paused = False
                self.script.stopped = False
                self.script.exception = None
                self.script.start()
                self.namedTraceList = set()

    def onPauseScript(self, paused):
        """Runs when pause script button clicked. Sets paused variable and wakes up script if unpaused."""
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.paused = paused
            if not paused:
                self.script.pauseWait.wakeAll()
        
    def onStopScript(self):
        """Runs when stop script button is clicked. Sets stopped variable and wakes up all waitConditions.""" 
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.stopped = True
            self.script.paused = False
            self.script.waitOnScan = False
            self.script.repeat = False
            self.script.analysisReady = True
            self.script.dataReady = True
            self.script.allDataReady = True
            self.script.guiWait.wakeAll()
            self.script.pauseWait.wakeAll()
            self.script.scanWait.wakeAll()
            self.script.dataWait.wakeAll()
            self.script.analysisWait.wakeAll()
            self.scanExperiment.namedTraceui.saveAndUpdateFileList()

    def onPauseScriptAndScan(self):
        """Runs when pause script and scan button is clicked."""
        self.onPauseScript(True)
        self.experimentUi.actionPause.trigger()
        
    def onStopScriptAndScan(self):
        """Runs when stop script and scan button is clicked."""
        self.onStopScript()
        self.experimentUi.actionStop.trigger()

    def onRepeat(self, repeat):
        """Runs when repeat button is clicked. Set repeat variable."""
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.repeat = repeat

    def onSlow(self, slow):
        """Runs when slow button is clicked. Set slow variable."""
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.slow = slow
            
    @QtCore.pyqtSlot(str)
    def onScanStateChanged(self, state):
        """Runs when the scan state changes"""
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.scanStatus = state
            if state == 'idle':
                self.writeToConsole("scan finished at {0}".format(str(datetime.now())), False, 'green')
                self.script.scanIsRunning = False
                self.script.scanWait.wakeAll()
            else:
                self.script.scanIsRunning = True

    @QtCore.pyqtSlot(object)
    def onAnalysisResult(self, allResults):
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.analysisResults = allResults
            self.script.analysisReady = True
            self.script.analysisWait.wakeAll()

    @QtCore.pyqtSlot(dict)
    def onData(self, data):
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.data = data
            self.script.dataReady = True
            self.script.dataWait.wakeAll()

    @QtCore.pyqtSlot(dict)
    def onAllData(self, allData):
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.allData = allData
            self.script.allDataReady = True
            self.script.allDataWait.wakeAll()

    @QtCore.pyqtSlot()
    def onFinished(self):
        for plottedTrace in list(self.scriptTraces.values()):
            plottedTrace.traceCollection.description["traceFinalized"] = datetime.now(pytz.utc)
            plottedTrace.traceCollection.save()
            self.registerMeasurement(plottedTrace)
        self.scriptTraces = dict()
        self.scanExperiment.namedTraceui.saveAndUpdateFileList(self.namedTraceList)

    @QtCore.pyqtSlot(str, bool, str)
    def onConsoleSignal(self, message, error, color):
        """Runs when script emits a console signal. Writes message to console."""
        self.writeToConsole(message, error=error, color=color)
    
    @QtCore.pyqtSlot(str, str)
    def onException(self, message, trace):
        """Runs when script emits exception signal. Highlights error."""
        logger = logging.getLogger(__name__)
        message = str(message)
        trace = str(trace)
        logger.error(trace)
        self.writeToConsole(trace, error=True)
        self.experimentUi.scriptingWindow.markError(self.currentLines, message)
    
    @QtCore.pyqtSlot(list)        
    def onLocation(self, locs):
        """Mark where the script currently is"""
        logger = logging.getLogger(__name__)
        self.currentLines = []
        if locs:
            self.currentLines = [loc[1] for loc in locs]
            for loc in locs:
                message = "Executing {0} in {1} at line {2}".format( loc[3], os.path.basename(str(loc[0])), loc[1] )
                logger.debug(message)
                self.writeToConsole(message, False)
        else: #This should never execute
            message = "onLocation called while not executing script"
            logger.warning(message)
            self.writeToConsole(message, True)
        self.experimentUi.scriptingWindow.markLocation(self.currentLines)
        
    def writeToConsole(self, message, error=False, color=''):
        """write a message to the console."""
        self.experimentUi.scriptingWindow.writeToConsole(message, error, color)

    def registerMeasurement(self, plottedTrace):
        """register a script created trace in the measurement log"""
        measurement = Measurement(scanType= 'Script', scanName=plottedTrace.traceCollection.filenamePattern,
                                  scanParameter='', scanTarget='',
                                  scanPP = '',
                                  evaluation='<Script {0}>'.format(self.script.shortname),
                                  startDate=plottedTrace.traceCollection.description['traceCreation'],
                                  duration=None,
                                  filename=plottedTrace.traceCollection.filename,
                                  comment=plottedTrace.traceCollection.comment,
                                  longComment=None,
                                  failedAnalysis=None)
        space = self.scanExperiment.measurementLog.container.getSpace('GlobalVariables')
        for name, value in self.experimentUi.globalVariablesUi.globalDict.items():
            measurement.parameters.append( Parameter(name=name, value=value, space=space) )
        measurement.plottedTraceList = [plottedTrace]
        self.scanExperiment.measurementLog.container.addMeasurement(measurement)

